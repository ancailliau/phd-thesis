% !TEX root = thesis.tex

\startcomponent chap-5
\environment common
\product thesis

\chapter[chap:controlling_obstacle]{Controlling Likely and Critical Obstacles}

  Once they are identified and assessed, obstacles needs to be resolved. Likely
  and critical ones have to be cost-effectively controlled through appropriate
  countermeasures yielding new goals to be integrated in the goal model.
  Alternative countermeasures are identified first; appropriate ones are
  selected next. As the countermeasures are integrated in the original goal
  model, the software requirements will be more complete in covering unexpected
  through possible situations.
  
  This chapter details what most appropriate countermeasure goals are, how
  cost-effective selection of countermeasures goals may be determined, and how
  selected countermeasure goals are integrated in the original model.

  An appropriate countermeasure selection ensures that the satisfaction rate of
  high-level goals becomes higher than their required satisfaction rate while
  maintaining a correct model. A {\it valid} countermeasure guarantee
  progress\emdash{}once integrated in the model, the satisfaction rate of some
  high-level goals has to increase. The chapter introduces integration schemas
  guaranteing that only the required parts of the model are modified. As the
  model is being modified, the propagation of changes ensures that the model
  remains correct after integration. As a result, a correct and more complete
  model is obtained.

  The chapter is organized as follows. \in{Section}[sec:identifying_cm] details
  what a valid countermeasure is. \in{Section}[sec:iterating_oa] discusses how
  the need for a new cycle of obstacle analysis on the countermeasure goals is
  determined. \in{Section}[sec:selecting_cm] details how countermeasures are
  assessed to be most appropriate and selected. \in{Section}[sec:integrating]
  describes how countermeasures are integrated into the goal model.

  \startsection[reference=sec:identifying_cm,title={Valid countermeasures}]
  
    Likely and critical obstacles should be controlled through appropriate
    countermeasures \cite[Lam09]. The latter are identified using heuristics
    such as {\it Avoid obstacle}, {\it Reduce obstacle likelihood}, {\it
    Mitigate obstacle}, {\it Weaken goal}, {\it Substitute goal}, {\it Restore
    goal}, or {\it Substitute agent} \cite[Lam00]; some may be automatically
    produced using the theory revision techniques \cite[Alr16].
    
    A {\it valid} countermeasure should ensure that its integration increases
    the satisfaction rate of some high-level goal.
    
    \startdefinition{Countermeasure integration}
    
      The {\it integration of a countermeasure goal $CG$} to a leaf obstacle $LO$ in
      goal model $M$, denoted $Int_{CG,LO}(M)$, maps $M$ to a new model $M'$
      such that $CG \in M'$.
    
    \stopdefinition
    
    Integrating a countermeasure might requires to de-idealize goals; those
    needs to be validated by domain experts.

    \startdefinition[def:de-idealized-goal]{De-idealized goal}
      
      A goal $G'$ is a {\it de-idealized} version of goal $G$ if $G \models G'$.
  
    \stopdefinition
    
    The application of the integration operator should increase the probability
    of satisfaction of some root goal at least, that is,
          
    \startdefinition{Progress}
      
      An integration $Int_{CG,LO}(M)$ guarantee {\it progress} if and only if
      there is at least one root goal $RG'$ in $M'$ corresponding to $RG$ in
      $M$ such that
          
      \startformula
      
        P_{M'} (RG') > P_M (RG)
      
      \stopformula
      
      where $P_M(G)$ refers to the satisfaction rate of $G$ in model $M$.
          
    \stopdefinition
    
    This progress property is guaranteed by valid countermeasures; Precisely, a
    {\it valid countermeasure} $CG$ for a leaf obstacle $LO$ satisfies one of
    the following conditions:
    
    \startformula\startalign[n=2,align={left,left}]
      \NC \{ LO', Dom' \} \models\not \neg OG' \NC \hskip2em \text{(non-obstruction)} \NR
      \NC \{ LO', Dom' \} \models false        \NC \hskip2em \text{(domain-inconsistency)} \NR
    \stopalign\stopformula
    
    where $M' = Int_{LO,CG}(M)$, $OG'$ is the obstructed goal in the model $M'$
    corresponding to $OG$, $LO'$ is the leaf obstacle in the model $M'$
    corresponding to $LO$, and $Dom'$ is the set of domain properties in the
    model $M'$. (As a recall, $p \models false$ means that there exists a
    behavior satisfying $p$.)
      
    The first condition may be relaxed in order to raise the obstruction on a
    higher-level goal $AG$, as in the {\it Strong mitigation} resolution tactic
    \cite[Lam00]:
      
    \startformula
      
      \{ LO', Dom' \} \models\not \neg AG' \hskip2em \text{(ancestor non-obstruction)}
      
    \stopformula
    
    where $AG'$ is the ancestor in $M'$ corresponding to $AG$, such that $AG$
    is an ancestor of the obstructed leaf goal $OG$.
    
    \noindent These conditions might be generalized for probabilistic goals and
    obstacles:
    
    \startformula\startalign[n=2,align={left,left}]
      \NC P ( \neg OG' \mid LO', Dom' ) < 1      \NC \hskip2em \text{(strong non-obstruction)} \NR
      \NC P ( LO', Dom' ) = 0                  \NC \hskip2em \text{(strong domain-inconsistency)} \NR
      \NC P ( \neg AG' \mid LO', Dom' ) < 1     \NC \hskip2em \text{(strong ancestor non-obstruction)} \NR
    \stopalign\stopformula
    
    These conditions are however strong and might prove to be unrealistic. The
    {\it strong non-obstruction} conditions does not account for weak goal
    obstructions as introduced in \in{Definition}[def:partial-obstruction].
    Those might be relaxed:
  
    \startformula\startalign[n=2,align={left,left}]
      \NC P ( \neg OG' \mid LO', Dom' ) <  P ( \neg OG \mid LO, Dom )    \NC \hskip2em \text{\tfx (weak non-obstruction)}\NR
      \NC P ( \neg AG' \mid LO', Dom' ) <  P ( \neg AG \mid LO, Dom )    \NC \hskip2em \text{\tfx (weak ancestor non-obstruction)}\NR
    \stopalign\stopformula
    
    The {\it strong domain-inconsistency} might also be relaxed to capture
    partial reduction:
    
    \startformula
    
       P ( LO', Dom' ) < P (LO, Dom)     \hskip2em \text{(weak domain-inconsistency)}
    
    \stopformula
    
    \startdefinition{Valid countermeasure}
    
      A {\it valid countermeasure} $CG$ for a probabilistic leaf obstacle $LO$
      satisfies one of the following conditions: {\it weak non-obstruction},
      {\it weak ancestor non-obstruction}, or {\it weak domain-inconsistency}.
    
    \stopdefinition
    
    A {\it valid countermeasure} is a sufficient condition for guaranteeing an
    increase in the satisfaction rate of some root goal.
    
    \startproposition{Valid countermeasures guarantee progress}
  
      The integration of a valid countermeasure guarantee progress.
      
    \stopproposition

    \startproof
    
      A valid countermeasure is such that its integration causes an increase in
      the satisfaction rate of the obstructed goal ({\it weak
      non-obstruction}), an increase in the satisfaction rate of an ancestor of
      the obstructed goal ({\it weak ancestor non-obstruction}), or a decrease
      in the satisfaction rate of the leaf obstacle ({\it weak domain
      inconsistency}). Therefore, the satisfaction rate of some root goal
      increases:

      \startitemize
        
        \item In a correct goal refinement, an increase in the satisfaction
        rate of a children goal results in an increase in the satisfaction rate
        of the parent goal. Otherwise, the goal refinement is not minimal as
        the satisfaction rate of the children might be reduced to $0$ without
        impacting the satisfaction of the parent goal.
      
        \item An decrease in the satisfaction rate of a root obstacle results
        in an increase in the satisfaction rate of the corresponding obstructed
        leaf goal. Otherwise, the refinement of the root obstacle is not
        domain-complete.
        
        \item In a correct obstacle refinement, a decrease in the satisfaction
        rate of a children obstacle results in a decrease in the satisfaction rate
        of the obstacle goal. Otherwise, the obstacle refinement is not minimal.
       
      \stopitemize
      
    \stopproof
    
    Obstacle resolution tactics such as {\it Avoid obstacle}, {\it Reduce
    obstacle likelihood}, {\it Mitigate obstacle}, {\it Weaken goal}, {\it
    Substitute goal}, {\it Restore goal}, or {\it Substitute agent}
    \cite[Lam00,Lam09] can be shown to produce valid countermeasures modulo
    propagations of their effect through the refinement trees in which they are
    involved (such propagation will be explained in
    \in{Section}[sec:integrating]).
    
    For example, the countermeasure goal \goal{Achieve [Redundant Pump Motor On
    When Primary Pump Failure]} to the obstacle \obstacle{Pump Electrical
    Failure}, shown in \in{Figure}[fig:redundant_pump], is valid. The obstacle
    \obstacle{Pump Electrical Failure} no longer obstruct \goal{Achieve [Make
    Up Water Provided When Requested]}; the {\it strong ancestor
    non-obstruction} condition is satisfied. This countermeasure together with
    \goal{Achieve [Valve Opened When Water Requested]} guarantee the
    satisfaction of the parent goal \goal{Achieve [Make Up Water Provided When
    Requested]}. In this example, the parent goal is not de-idealized.

    \placefigure[bottom]
    	[fig:redundant_pump]
    	{A countermeasure goal to the obstacle \obstacle{Pump Electrical Failure}.}
      {\externalfigure[../images/chap5/redundant_pump.pdf][scale=1000]}

    Multiple candidate ancestors might be considered for the {\it weak ancestor
    non-obstruction} condition. In our example, \goal{Achieve [Make Up Water
    Provided When Requested]} and \goal{Achieve [Make Up Water Provided When
    Loss Of Cooling]} are potential candidates with respect to the goal
    \goal{Achieve [Redundant Pump Motor On When Primary Pump Failure]}. 
    
    The nearest candidate to this goal in the goal graph appears preferable to
    ensure more local model changes\emdash{}that is, in our example the goal
    \goal{Achieve [Make Up Water Provided When Requested]}. The lower ancestor
    the more local the change as goals above the ancestor are likely not
    modified whereas the descedants are likely modified; less goals are thereby
    impacted by the integration when a lower ancestor is considered.

    \startdefinition{Anchor goal}
    
      The {\it anchor goal} of a countermeasure goal $CG$ is the lowest
      ancestor goal $AG$ meeting the {\it weak ancestor non-obstruction}
      condition.
      
    \stopdefinition
    
    As discussed in \in{Section}[sec:integrating], the anchor goal of a
    coutermeasure goal is the goal through which the countermeasure goal is
    integrated.
    
  \stopsection
  
  \startsection[reference=sec:iterating_oa,title={Iterating obstacle analysis}]

    As \in{Figure}[fig:redundant_pump] shows, a countermeasure goal should
    itself be refined down to leaf goals assignable to single agents. These
    leaf goals might be obstructed by new obstacles; a new cycle of obstacle
    analysis may be therefore needed at RE time. 
    
    To determine whether a new obstacle
    analysis cycle is required, the maximal change in satisfaction rate of the
    considered high-level goals should be taken into account. 
    
    \startitemize
    
      \item At best, the satisfaction rate of the countermeasure goal is $1$
      (no possible obstruction of it). By up-propagation, this satisfaction
      rate leads to a satisfaction rate $sr_1$ for the high-level goal.
    
       \item At worst, the satisfaction rate is $0$. This leads to another
       satisfaction rate $sr_0$ for the high-level goal.
    
    \stopitemize
    
    \noindent The countermeasure's {\it maximal impact} is then obtained by
    taking the difference:
    
    \startformula
    
      sr_1 - sr_0.
    
    \stopformula
    
    Based on this, the analyst may decide at RE time whether a new cycle is
    needed or not.

    \startluacode
      sr0 = 81.74
      sr1 = 94.94
      max_sr = sr1 - sr0
    \stopluacode

    For example, consider the countermeasure goal \goal{Achieve [Redundant Pump
    Motor On When Primary Pump Failure]}. If the satisfaction rate of this
    countermeasure is $0$, the satisfaction rate of the high-level goal
    \goal{Achieve [Make Up Water Provided When Loss Of Cooling]} is
    \ctxlua{round2(sr0)}\%. If the satisfaction rate of this countermeasure is
    1, the satisfaction rate of the high-level goal is \ctxlua{round2(sr1)}\%.
    The maximal impact on the high-level goal is thus
    \ctxlua{round2(max_sr)}\%. As the impact is felt important, it may be worth
    spending time in studying obstacles to this countermeasure goal at RE time
    to better estimate the impact of its deployment.
  
  \stopsection
  
	\section[sec:selecting_cm]{Selecting valid countermeasures to obstacle}

    Thanks to the {\it progress} property introduced before, a valid
    countermeasure integrated into the goal model results in an increase of the
    satisfaction rate of some high-level goal. This quantifies the impact of a
    countermeasure; it is the key for selecting the most appropriate
    countermeasures; the latter are maximizing such impact.

    \in{Section}[sec:assessing_impact] describes how the impact of alternative
    countermeasures is assessed. \in{Section}[sec:most_appropriate] clarifies
    what most appropriate countermeasures are to be selected and deployed when
    an obstacle resolution is required. \in{Section}[sec:selecting_cm] explains
    how such selection is systematically determined.

		\subsection[sec:assessing_impact]{Assessing countermeasures impact}
  
      The integration of a countermeasure goal into the goal model impacts the
      satisfaction rate of a high-level goal. As \in{Section}[sec:integrating]
      will show, depending on the specific obstacle resolution strategy and
      associated countermeasure integration schema being chosen, the obstructed
      goal is either removed from the goal model or kept. In the former case,
      the obstructed goal is replaced by the countermeasure goal; in the latter
      case, a new refinement is introduced involving both the obstructed goal
      and the countermeasure goal. The satisfaction rate of the high-level goal
      is computed as described next to evaluate the impact of the
      countermeasure.

      \startitemize

      \item {\bf Assessing countermeasure impact when the obstructed goal is
      replaced.} In this case, when the satisfaction rate of the high-level
      goal is computed as described in \in{Section}[sec:computing_satrate], the
      propagation procedure computing the satisfaction rate of a high-level
      goal need to use the satisfaction rate of the countermeasure goal in
      place of the satisfaction rate of the replaced goal.
  
      For example, the goal \goal{Achieve [Make Up Water Automatically
      Requested When Alarm Raised]} was generated using the {\it Agent
      Substitution} strategy \cite[Lam00]. When integrated, it replaces the
      goal \goal{Achieve [Make Up Water Requested When Alarm Raised]}. The
      computation of the satisfaction rate of the parent goal \goal{Achieve
      [Make Up Water Requested When Loss Of Cooling]} uses the satisfaction
      rate of this countermeasure goal rather than the satisfaction rate of the
      replaced goal. When integrated, the satisfaction rate of the top goal
      increases from 81.74\% to 81.77\%.
    
%     To enable efficient computation of the impacts, the BDD-based propagation
%     technique is extended to support resolutions. We introduce a new binary 
%     variable $R_i$ that indicates whether the resolution $i$ is selected.
%     As recall, the obstruction superset for a goal $PG$ refined with two
%     subgoals $G_1$ and $G_2$ is given by
%
%     \startformula
%       OS(PG) = OS(G_1) \cup OS(G_2)
%     \stopformula
%     
%     Assume a resolution $i$ with anchor goal $PG$, countermeasure goal $CM$
%     and whose corresponding obstructed goal is $G_2$. If resolution $i$ is
%     integrated, the obstruction superset for $PG$ should be:
%
%     \startformula
%       OS(PG) = OS(G_1) \cup OS(CM)
%     \stopformula
%     
%     Using an extra variable $R_i$, the obstruction superset is given by
%     
%     \startformula\startalign[n=3]
%       \NC OS(PG) \NC = \NC (OS(G_1) \cup OS(G_2)) \times \{\neg R_i\} \NR
%       \NC        \NC   \NC \cup (OS(G_1) \cup OS(CM)) \times \{R_i\}  \NR
%     \stopalign\stopformula
%     
%     When computing the probability of the obstruction superset, $R_i$
%     is assigned $1$ if the resolution is selected, $0$ otherwise.
%     
%     \noindent In the example above, before integrating the resolution, we
%     have:
%
%     \startformula\startalign[n=1,align=left]
%       \NC OS(\goal{Achieve [Make Up Water Requested When Loss Of Cooling]}) \NR\noalign{\vskip-.5em}
%       \NC \hskip1cm = \{\{\obstacle{Alarm Not Raised And Low Water}\}, \NR\noalign{\vskip-.5em}
%       \NC \hskip2cm \{\obstacle{Make Up Water Not Requested And Alarm Raised}\}\} \NR
%     \stopalign\stopformula
%     
%     When the resolution is integrated, we have:
%
%     \startformula\startalign[n=1,align=left]
%       \NC OS(\goal{Achieve [Make Up Water Requested When Loss Of Cooling]}) \NR\noalign{\vskip-.5em}
%       \NC \hskip1cm = \{\{\obstacle{Alarm Not Raised And Low Water}\}\} \NR
%     \stopalign\stopformula
%     
%     Using the extra variable $R$ to represent the selection of the
%     aforementioned resolution, we have
%
%     \startformula\startalign[n=1,align=left]
%       \NC OS(\goal{Achieve [Make Up Water Requested When Loss Of Cooling]}) \NR\noalign{\vskip-.5em}
%       \NC \hskip1cm = \{\{\neg R, \obstacle{Alarm Not Raised And Low Water}\}, \NR\noalign{\vskip-.5em}
%       \NC \hskip2cm \{\neg R, \obstacle{Make Up Water Not Requested And Alarm Raised}\} \NR\noalign{\vskip-.5em}
%       \NC \hskip2cm \{R, \obstacle{Alarm Not Raised And Low Water}\}\} \NR
%     \stopalign\stopformula
  
      \item {\bf Assessing countermeasure impact when the obstructed goal is
      kept.} In this case, the anchor goal is refined into two subgoals; one
      subgoal is the obstructed goal conjoined with the negation of the
      obstacle condition; the other subgoal is the countermeasure goal. The
      satisfaction rate of the anchor goal is obtained using the satisfaction
      rates of those two subgoals, as described
      \in{Section}[sec:computing_satrate].
  
      For example, integrating the countermeasure goal \goal{Achieve [Redundant
      Pump Motor On When Primary Pump Failure]} causes the anchor goal to be
      refined in two subgoals: \goal{Achieve [Make Up Water Provided When
      Requested And No Pump Failure]} and \goal{Achieve [Redundant Pump Motor
      On When Primary Pump Failure]}. The satisfaction rate of the root goal
      increases from 81.74\% to 94.94\%: The down-propagation of changes in the
      goal graph reduces the formal specification of the obstacles
      \obstacle{Pump Electrical Failure} and \obstacle{Pump Mechanical Failure}
      to {\it false}; The satisfaction rate of the latter is therefore $0$.
    
%     Similarly to assessing when the obstructed goal is removed, the BDD-based propagation 
%     is extended to support these resolutions. As in \in{Figure}[fig:integration_remove],
%     assume a resolution $i$ with anchor goal $AG$, countermeasure goal $CM$
%     and whose corresponding leaf obstacle is $LO$. If resolution $i$ is
%     integrated, the obstruction superset for $PG$ should be:
%
%     \startformula
%       OS(AG') = \{os\setminus\{LO\}\mid os\in OS(AG)\} \cup OS(CM)
%     \stopformula
%     
%     The leaf obstacle is removed from the obstruction set of the obstructed
%     goal $AG$ and obstacles to the countermeasure goal are taken into
%     account. Using an extra variable $R_i$, the obstruction superset is given
%     by
%     
%     \startformula\startalign[n=3]
%       \NC OS(AG') \NC = \NC (OS(AG) \times \{\neg R_i\}) \NR
%       \NC         \NC   \NC \cup (\left[\{os\setminus\{LO\}\mid os\in OS(AG)\} \cup OS(CM)\right] \times \{R_i\}) \NR
%     \stopalign\stopformula
  
      \stopitemize
  
      Such computation is very easy when specific notations for goal exception
      and goal replacement are used, see \in{Section}[sec:integrating] below.
      The resolutions are added and removed to evaluate the impact of the
      countermeasure.
      
      This however requires the BDD to be built at each combination, which
      slows down the process. Improvements can be envisioned as one could build
      a single BDD covering all possible combinations using extra variables to
      encode which resolution is selected; Such BDD could be computed once at
      RE-time.
  
		\subsection[sec:most_appropriate]{What are most appropriate countermeasures?}
	
      The selection among alternative countermeasure that were identified
      should increase the satisfaction rate of high-level goals beyond their
      Required Satisfaction Rate (RSR) at reasonable cost.
    
      \startdefinition{Safe Selection}
    
        A {\it safe selection} of countermeasures is a set of countermeasures
        that, once integrated, guarantees that the satisfaction rate of the
        high-level goals considered is greater than their respective RSR.
    
      \stopdefinition
    
      A selection of countermeasures must be consistent; conflicting
      countermeasures may not be selected together:
    
      \startformula
        \{CM_i, CM_j, Dom\} \nvDash false \text{ for } i \neq j \hskip1cm \text{(selection-consistency)}
      \stopformula
    
      Countermeasures come with a cost. The latter are elicited with regard to
      the countermeasure's contributions to soft goals in the goal model (See
      \in{Section}[sec:soft_goal]) \emdash{}such as \goal{Maximize\-[Operator
      Safety]}, \goal{Minimize\-[Power Consumption]} or \goal{Maximize\-[Speed
      Computation]}. Without loss of generality, only single costs are
      considered here. Multiple costs can be combined by a weighted sum where
      weights correspond to the priorities of the considered soft goals.

      \startdefinition{Countermeasure selection resolution cost}

        The {\it resolution cost} of a selection is the sum of the costs
        associated with the selected countermeasures.

      \stopdefinition

      \startdefinition{Cost-optimal selection}

        A selection is {\it cost-optimal} if no other selection increases the
        probability of satisfaction of the high-level goal without increasing
        the resolution cost.
      
      \stopdefinition
      
      The selection of most appropriate countermeasures is defined as the one
      having the lowest resolution cost such that the satisfaction rate of the
      high-level goals is maximized while being safe, consistent, and
      cost-optimal.
        
		\subsection[sec:selecting_cm]{Selecting most appropriate countermeasures}

      The selection of most appropriate countermeasures thus amounts to solving two
      optimization problems:
    
      \startitemize[n]

        \item Finding the minimal cost for guaranteeing the RSR of the considered
        high-level goals,
        
        \noindent
        We may iteratively generate all possible selections and keep the
        selection that minimizes cost while guaranteeing that the RSRs are met.
        The complexity of this naïve approach is $O(2^n)$ where is $n$ the
        number of countermeasures.

        \item Finding the selections that maximize the satisfaction rate of
        the high-level goals given this cost.
        
        \noindent
        We may then generate all possible selections, compute their cost, and
        keep the selection with a minimal cost and the largest satisfaction
        rate of the high-level goals. The complexity of this naïve computation
        is $O(2^n)$ for $n$ countermeasures.

      \stopitemize
    
      In our example, the minimal cost for guaranteeing the RSR of 95\% for the
      goal \goal{Achieve [Make Up Water Provided When Loss Of Cooling]} is 1.
      With 6 possible resolutions, there are 63 possible selections. Among them
      24 are safe selections that guarantee the RSR with costs ranging from 1
      to 6 (we used unitary costs for the countermeasure goals). A single
      selection of two countermeasure goals maximizes the satisfaction rate of
      \goal{Achieve [Make Up Water Provided When Loss Of Cooling]}, namely,
      \goal{Achieve [Cooling System Repaired]} and \goal{Achieve [Power
      Supplied When Primary Power Supply Failure]}. On this running example,
      the best satisfaction rate that can be achieve is 97.18\%.
    
      Our naïve approach to selecting the most appropriate countermeasures
      could be improved by exploring different directions:
    
      \startitemize
    
        \item The problem of finding a cost-optimal selection shares
        similarities with the NP-hard Knapsack optimization problem
        \cite[Cor09]. The latter is concerned with filling a bag with valued
        items without exceeding a maximal weight while maximizing value. The
        problem here differs in that {\it (i)} the value and weight of items do
        not simply sum; and {\it (ii)} adding a new countermeasure goal does
        not necessarily increase the satisfaction rate of a high-level goal.
        Improvements of our naïve algorithms are however expected as a
        pseudo-polynomial algorithm exists for the Knapsack problem
        \cite[Cor09].
  
        \item Other techniques such as \cite[Men03] might also improve
        selections. Incremental control learning is a technique that present,
        at each iteration, a set of key variables (in our case, countermeasure
        goals) that have the most impact on the system. This technique has
        already been applied to select risk mitigations in the DDP framework,
        showing promising results. (See \in{Chapter}[chap:relatedwork] for a
        detailed discussion about DDP.)
    
        \item Lastly, the Cross-Entropy method is an optimization technique for
        solving combinatorial problems \cite[DeB05,Jeg12]. Applied to our
        problem, the method can be broken in two steps: {\it (1)} an initial
        selection is generated; {\it (2)} the parameters of the random
        generation are updated according the score of the generated selection.
        The steps are run a large number of times. Such technique has been
        successfully applied for selecting software adaptations at runtime
        \cite[Mor17].
    
      \stopitemize

  
  \startsection
    [reference=sec:integrating,
     title={Integrating selected countermeasures in the goal model}]
	
    The selected countermeasures should be integrated in the original goal model.
    For a given obstacle, integrating a countermeasure goal to an obstacle in a
    goal model means:
    
    \startitemize[a]
    
      \item Connecting this goal to a parent node in the model;
    
      \item Adding other sibling subgoals in the refinement, if necessary;
    
      \item Propagating the corresponding changes along refinement trees in
      which the countermeasure goal is involved;
    
      \item Refining this goal if necessary.
    
    \stopitemize

    In addition to the progress property introduced in
    \in{Section}[sec:identifying_cm], the integration $Int_{CG,LO}(M)$ of a
    countermeasure $CG$ to a leaf obstacle $LO$ in goal model $M$ should
    satisfy the {\it minimal change} and {\it correctness preservation}
    properties.
      
    \startdefinition{Minimal change} 
    
      An integration $Int_{CG,LO}$ guarantee {\it minimal changes} if it
      preserve prescribed behaviors in $M$ that are not affected by $LO$. That
      is, for any goal $G$ in $M$ such that $\{LO, Dom\} \models\not \neg G$ and
      corresponding goal $G'$ in $M'$, we should have:
      
      \startformula 
        G' \models G.
      \stopformula
      
    \stopdefinition
    
    \startdefinition {Correctness preservation} 
    
      An integration $Int_{CG,LO}$ guarantee {\it correctness preservation} if
      the correctness of goal refinements in $M$ is preserved in $M'$. That is,
      if all refinements in $M$ are complete, consistent, and minimal then
      those in $M'$ are complete, consistent, and minimal as well.
    
    \stopdefinition

    \in{Section}[sec:integration_schema] shows how the minimal change property
    can be guaranteed by countermeasure integration schemas.
    \in{Section}[sec:propagation] details how correctness is preserved through
    the integration. In these two sections the countermeasure goals are
    introduced in the original goal model by modification of the refinement
    structure. \in{Section}[sec:exception_handling] proposes a notational
    mechanism for improving the documentation of obstacle handling seen as
    exception handling in goal models.
	
    \startsubsection
      [reference=sec:integration_schema,
       title={Integration schemas for ensuring minimal changes}]
        
      The integration of a single valid countermeasure goal ensures progress
      towards a more complete model; it should also ensure that the {\it
      minimal change} property is met, that is, nothing more than necessary is
      modified.

      Two alternative integration schemas may be used for this, dependent on
      the obstacle resolution tactic being selected \cite[Lam09,Lam00]. 
      
      \startitemize

        \item The first schema removes the obstructed goal; it should be
        applied when the {\it substitute goal} or {\it weaken goal} tactic is
        used for resolving the obstacle.
      
        \item The second integration schema keeps the obstructed goal in the
        model; it should be applied when the {\it avoid obstacle}, {\it reduce
        obstacle likelihood}, or {\it mitigate obstacle} tactic is used.
        
      \stopitemize

      \noindent {\bf Removing the obstructed goal.}
      \in{Figure}[fig:integration_remove] shows a first integration schema
      expressed as a model rewriting rule. On the left, the countermeasure goal
      $CG$ is not integrated whereas the latter is integrated on the right. In
      this first schema, the refinement of anchor goal $AG$, containing at
      least one obstructed goal, is replaced by a new refinement. The latter
      contains the countermeasure goal $CG$ to leaf obstacle $LO$ together with
      all non-obstructed children, that is $G_3$. (An anchor's obstructed
      children are those being directly or indirectly obstructed by $LO$.) The
      anchor $AG$ may need to be de-idealized; in this case, $AG'$ replaces
      $AG$ in the modified goal model. The de-idealization might requires
      de-idealization of other connected goals such as $G_1$ and $PG$.

      \placefigure[here]
      	[fig:integration_remove]
      	{Integration schema with obstructed goal being removed.}
        {\externalfigure[../images/chap5/integration_remove.pdf][scale=1000]}

      This first integration schema has a precondition for use, namely, the
      countermeasure goal $CG$ and the non-obstructed children must be sufficient for
      satisfying the anchor goal:
      
      \startformula
        \{CG, Children(AG) \setminus ObstructedChildren(AG,LO)\} \models AG'
      \stopformula

      where $ObstructedChildren(AG,LO)$ denotes the children of $AG$ obstructed
      by the leaf obstacle $LO$, and $Children(AG)$ denotes the children of the
      anchor goal $AG$. Otherwise, the new refinement would not be complete.

      For example, the goal \goal{Achieve [Make Up Water Requested When Alarm
      Raised]} assigned to the agent \agent{Controlling Software} is a
      countermeasure produced through the {\it agent substitution} tactic
      \cite[Lam09,Lam00]. Its anchor goal is \goal{Achieve [Make Up Water
      Requested When Loss Of Cooling]}. The following refinement is complete,
      consistent, and minimal for this anchor goal:

      \startkaosspec
        Achieve [Make Up Water Requested When Loss Of Cooling]\blank[none]
        \rightarrow\hskip.5em Achieve [Make Up Water Requested When Alarm Raised]\blank[none]
        \rightarrow\hskip.5em Achieve [Alarm Raised When Low Water]
      \stopkaosspec

      \noindent We may therefore replace the old refinement by this one.

      It is easy to see that this first integration schema meets our minimal
      change property. Non-obstructed goals are composed from non-obstructed
      goals in the AND-refinements of $AG$ and its descendants, and in the siblings
      of $AG$ and its ancestors. The former are kept as is whereas the latter
      might need to be de-idealized through change propagation (see
      \in{Section}[sec:propagation]). All these goals thus satisfy $G' \models
      G$.

      \noindent {\bf Keeping the obstructed goal.}
      \in{Figure}[fig:integration_keep] shows a second integration schema. In
      this schema, a new refinement is introduced; it includes a de-idealized
      version of the obstructed anchor and the countermeasure goal. The
      obstructed anchor is de-idealized for removing the obstruction. The
      negation of the leaf obstacle is added to form a {\it by-case}
      AND-Refinement \cite[Lam00].

      \placefigure[here]
      	[fig:integration_keep]
      	{Integration schema with obstructed goal being kept.}
        {\externalfigure[../images/chap5/integration_keep.pdf][scale=1000]}

      This second integration schema has a precondition for use as well,
      namely, the countermeasure goal must be sufficient for satisfying the
      anchor goal when the obstacle occurs:

      \startformula
        \{LO, CG, Dom\} \models AG'
      \stopformula
      
      For example, the countermeasure goal \goal{Achieve [Cooling System
      Repaired]} entails its anchor \goal{Achieve [Make Up Water Provided When
      Loss Of Cooling]} when the obstacle \obstacle{Valve Mechanical Failure}
      occurs. This second integration schema then produces the following refinement:

      \startkaosspec
        Achieve [Make Up Water Provided When Loss Of Cooling]\blank[none]
        \rightarrow\hskip.5em Achieve [Make Up Water Provided When Loss Of Cooling\blank[none]
        \hskip4em And No Valve Mechanical Failure]\blank[none]
        \rightarrow\hskip.5em Achieve [Cooling System Repaired]
      \stopkaosspec

      Note that the anchor goal is not de-idealized in this example. The new
      goal \goal{Achieve [Make Up Water Provided When Loss Of Cooling And No
      Valve Mechanical Failure]} is a de-idealization of the anchor goal. The
      negation of the obstacle is added to the goal antecedent:

      \startformula
        LossOfCooling \hskip.7ex\graymath{\wedge\hskip.5ex \neg MakeUpValveFailure}\hskip.7ex 
        \Rightarrow \ltlF_{\leq 55h} MakeUpWaterProvided
      \stopformula

      This second integration schema can be seen to meet our minimal change
      property as well; the reasoning is similar to the first schema. Only
      siblings of the anchor goal and its ancestor may need to be de-idealized.
      The other goals were obstructed by the resolved obstacle and are
      therefore not concerned by the minimal change property.
    
    \stopsubsection
    
    \startsubsection
      [reference=sec:propagation,
       title={Change propagation for preserving refinement correctness}]
      
      Goal de-idealization and countermeasure integration may require
      corresponding changes to be propagated along refinement trees in which
      the countermeasure goal is involved. Such propagations are intended to
      ensure our third property on integrations, that is, the resulting model
      must remain {\it complete}, {\it consistent}, and {\it minimal} as
      defined in \in{Section}[sec:modeling_probabilistic_goals]. This section
      discusses how de-idealizations and change propagation can be performed.

      \noindent {\bf De-idealization by strengthening the goal's antecedent.} A
      first way of de-idealizing a goal of form $C\Rightarrow\Theta T$ is to add
      an adequate conjunct to its antecedent:

      \startformula
        AddConjunct (C \Rightarrow \Theta T, \Theta EC) 
          = \[C \wedge \Theta EC\] \Rightarrow \Theta T
      \stopformula

      For example, the goal \goal{Achieve [Make Up Pump Motor On When Water
      Requested]} may be de-idealized so as to exclude pump failure from pump
      actuation:

      \startformula
        WaterRequested \wedge \neg PumpFailure \Rightarrow \ltlF_{\leq 5m} PumpMotorOn
      \stopformula

      \noindent {\bf De-idealization by weakening the goal's consequent.} A
      second way of de-idealizing the goal $C\Rightarrow\Theta T$ is to add an
      adequate disjunct to its consequent:

      \startformula
        AddDisjunct (C \Rightarrow \Theta T, \Theta EC) 
          = C \Rightarrow \[\Theta T \vee \Theta EC\]
      \stopformula

      For example, the goal \goal{Achieve [Make Up Pump Motor On When Water
      Requested]} might be de-idealized so as to require the pump or the
      redundant pump to be actuated:

      \startformula
        WaterRequested \Rightarrow \ltlF_{\leq 5m} PumpMotorOn 
          \vee \ltlF_{\leq 10m} RedundantPumpMotorOn
      \stopformula

      \noindent {\bf Change propagation.} When a goal is de-idealized, the
      change must be propagated along the refinement trees in which this goal
      is involved\emdash{}both up and down such trees. When applying the {\it
      AddConjunct} or {\it AddDisjunct} operators the corresponding syntaxic
      changes are applied recursively to the other goals up and down refinement
      links.

      \placefigure[here]
      	[fig:cooling_repaired]
      	{A countermeasure goal to the obstacle \obstacle{Valve Mechanical 
         Failure}.}
        {\externalfigure[../images/chap5/cooling_repaired.pdf][scale=1000]}

      For example, the integration of the countermeasure goal \goal{Achieve
      [Cooling System Repaired]} for the obstacle \obstacle{Valve Mechanical
      Failure}, as shown in \in{Figure}[fig:cooling_repaired], requires change
      propagation to the descendants of the goal \goal{Achieve [Make Up Water
      Provided When Loss Of Cooling]}. First, this goal is modified as
      previously shown:
        
      \startformula
        LossOfCooling \wedge \neg MakeUpValveFailure 
          \Rightarrow \ltlF_{\leq 55h} MakeUpWaterProvided
      \stopformula
      
      Next, the change is down-propagated, leading to an application of {\it
      AddConjunct} to the goal \goal{Achieve [Make Up Water Provided When
      Requested]}:
        
      \startformula\startalign[n=1,align={left}]
        \NC MakeUpWaterRequested \wedge \neg MakeUpValveFailure \NR\noalign{\vskip-.5em}
        \NC \hskip1em\Rightarrow \ltlF_{\leq 24h} MakeUpWaterProvided \NR
      \stopalign\stopformula
      
      The next refinement instantiates the {\it divide-and-conquer} refinement
      pattern \cite[Lam00]. The {\it AddConjunct} operator is applied to the goal
      \goal{Achieve [Valve Opened When Water Requested]}. (This operator could
      have been applied to the goal \goal{Achieve [Make Up Pump Motor On When
      Water Requested]} but the latter was assumed irrelevant.) We obtain:

      \startformula\startalign[n=1,align={left}]
        \NC MakeUpWaterRequested \wedge \neg MakeUpValveFailure  \NR\noalign{\vskip-.5em}
        \NC \hskip1em\Rightarrow \ltlF_{\leq 15m} MakeUpValveOpen \NR
      \stopalign\stopformula

      Since this goal is a leaf goal, the propagation ends.

      Change propagation in the general case proceeds as follows, as in
      \cite[Lam98b]. 
      
      \startitemize
      
        \item When {\it AddConjunct} is applied to a goal for de-idealization,
        the specification pattern followed by the formal specification of the
        goal is identified and used to extract the antecedent.
      
        \item The de-idealized antecedent is obtained by adding the
        conjunction. The original antecedent is then replaced by the de-idealized
        one.
      
        \item The process is applied recursively to the subgoals (resp.
        parents) until leaf goals (resp. root goals) are reached.
      
      \stopitemize
      
      The procedure is similar when applying {\it AddDisjunct}.
      
      Such change propagation produces formal specifications that often need to
      be simplified. Moreover, other mechanisms are required for change
      propagation to goals not matching a known specification pattern. Even
      though pattern-based propagation can be performed semi-automatically,
      interaction with the analyst is required when no specification pattern
      can be matched. The general problem of automatic change propagation
      through arbitrary refinement structures remains open.
    
    \stopsubsection
    
		\startsubsection
      [reference=sec:exception_handling,
       title={Obstacle resolution as exception handling}]

      The integration of countermeasure goals as such through new, explicit refinements
      in the original model raises several issues.
      
      \startitemize
        
        \item The goal graph might undergo significant changes every time a new
        obstacle is identified.
        
        \item Normal situations are mixed with exceptional ones; it may prove
        hard to distinguish the former from the latter without domain
        expertise.
        
        \item Goal specifications become increasingly more complex.
        
        \item As new countermeasures are introduced, the ordered nesting of
        exceptional cases along refinements may lead to a combinatorial blow-up
        of special cases.

      \stopitemize
      
      \noindent This section shows how dedicated constructs may help addressing
      these issues.
      
      \noindent {\bf Extending the goal specification language.} Dedicated
      constructs are proposed for encapsulating the required modifications
      while documenting each exceptional case separately.
    	  
      \noindent {\bi Except.} A first construct links a countermeasure goal to
      its anchor goal:
      
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {FormalSpec} {$C\Rightarrow\Theta T$}
        \KaosAttribute {Except} {$O$ {\cronos\bf then} $CG$}
      \stopkaosspec
      
      \noindent where $AG$ denotes the anchor goal $C \Rightarrow \Theta T$
      of a countermeasure goal $CG$ to an obstacle $O$. Semantically, this
      implicit specification is fully equivalent to the refinement in
      \in{Figure}[fig:except_semantic]. This construct may be used under the
      following precondition:

      \startformula
        \{O, CG, Dom\} \models AG
      \stopformula

      \placefigure[top]
      	[fig:except_semantic]
      	{Semantic equivalent of {\it Except}.}
        {\externalfigure[../images/chap5/except_semantic.pdf][scale=1000]}

      For example, consider the goal \goal{Achieve [Make Up Water Provided When
      Loss Of Cooling]}. Under the exceptional condition of a mechanical
      failure of the make-up valve, the goal is guaranteed through repairing
      the cooling system. We may therefore specify the following:
   
      \startkaosspec
        \GoalName {Achieve [Make Up Water Provided When Loss Of Cooling]}
        \KaosAttribute {FormalSpec} {$C\Rightarrow\Theta T$}
        \KaosAttribute {Except} {Valve Mechanical Failure {\cronos\bf then} Achieve [Cooling System Repaired]}
      \stopkaosspec
     
      This specification is logically equivalent to the refinement illustrating
      the second integration schema in \in{Section}[sec:integrating].

      Multiple {\it Except} annotations may be attached to a single goal to
      cope with different obstacles; the latter may therefore be introduced
      incrementally.
      
      Compared with the complexity of an equivalent explicit specification, the
      complexity of an implicit goal specification with multiple {\it Except}
      annotations remains linear in the number of exceptions. The specification
      of the original goal remains unchanged. Moreover, multiple annotations
      sharing the same countermeasure goal may be factored out to simplify the
      model.

      \noindent {\bi Provided.} A second construct specifies an extra conjunct
      on the antecedent of an original goal $G$ to produce a countermeasure:
   
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {FormalSpec} {$C\Rightarrow\Theta T$}
        \KaosAttribute {Provided} {$EC$}
      \stopkaosspec
      
      \noindent where $EC$ denotes an extra conjunct to be added to the goal
      antecedent for resolving the considered obstacle. Semantically, this
      implicit specification is equivalent to:
   
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {FormalSpec} {$C \wedge EC \Rightarrow \Theta T$}
      \stopkaosspec

      The {\it Provided} construct is typically used for de-idealizing goals.
      For example, the de-idealization of the goal \goal{Achieve [Make Up Pump
      Motor On When Water Requested]} may be specified by highlighting the
      normal situation as follows:
   
      \startkaosspec
        \GoalName {Achieve [Make Up Pump Motor On When Water Requested]}
        \KaosAttribute {Provided} {$\neg PumpMechanicalFailure$}
      \stopkaosspec
          
      \noindent It often proves convenient to write {\it ProvidedNot $EC$} instead of
      {\it Provided $EC$}.
      
      \noindent {\bi RelaxedTo.} Symmetrically to {\it Provided}, this
      construct specifies an extra disjunct on the consequent of an original goal
      G to produce a countermeasure:
      
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {FormalSpec} {$C\Rightarrow\Theta T$}
        \KaosAttribute {RelaxedTo} {$ED$}
      \stopkaosspec

      \noindent where $ED$ denotes an extra disjunct to be added to the goal consequent
      for resolving the considered obstacle. Semantically, this goal is
      equivalent to:
      
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {FormalSpec} {$C \Rightarrow \Theta T \vee ED$}
      \stopkaosspec

      This construct is useful for de-idealizing goals as well. For example,
      another de-idealization of the same goal \goal{Achieve [Make Up Pump Motor
      On When Water Requested]} might be specified by highlighting the normal
      situation as follows:
      
      \startkaosspec
        \GoalName {Achieve [Make Up Pump Motor On When Water Requested]}
        \KaosAttribute {RelaxedTo} {$RedundantPumpMotorOn$}
      \stopkaosspec
      
      Multiple {\it Provided} and {\it RelaxedTo} annotations may be attached
      to a single goal to introduce multiple countermeasures.
      
      \noindent {\bi Replaces.} This construct appears useful for tracing
      previous versions of a goal:
      
      \startkaosspec
        \GoalName {$AG$}
        \KaosAttribute {Replaces} {$AG'$}
      \stopkaosspec
      
      \noindent Such traceability helps readers understand the rationale behind
      the final goal.
      
      \noindent {\bf Model refactoring for goal exceptions.} In practice, the
      analyst should decide at some point whether a countermeasure goal refers
      to an exceptional situation or to a normal one to be considered in the
      original goal model. Such a decision might depend on various factors such as
      the satisfaction rate of the resolved obstacle, the criticality of the
      obstructed goal, domain-specific culture, stakeholders wishes, and so
      forth. To make the decision flexible and easily reversible, model
      refactoring operators are proposed for attaching or detaching the
      annotations introduced in the previous section to/from a goal model.
      Three operators are available for transforming an annotated model portion
      into a standard one.

        \placefigure[bottom]
        	[fig:refactoring_except]
        	{Implicit and explicit countermeasure integration.}
          {\startcombination[2*1]
            {\externalfigure[../images/chap5/refactoring_except_a.pdf]}{\tfx(a)}
            {\externalfigure[../images/chap5/refactoring_except_b.pdf]}{\tfx(b)}
           \stopcombination
          }
        
        \noindent {\bi Detach-Except}, applied to an annotated goal, produces a
        new model where the goal is no longer annotated with a specific {\bi
        Except} clause. The operator introduces a new refinement with two
        children: the countermeasure goal and a de-idealization of the original
        goal (see \in{Figure}[fig:except_semantic] from left to right). The
        children of the original goal are then children of the de-idealized
        goal. Back to an earlier example, the operator takes the model fragment
        in \in{Figure}{a}[fig:refactoring_except] to produce the model fragment
        in \in{Figure}{b}[fig:refactoring_except].

        \noindent {\bi Detach-Provided}, applied to an annotated goal, produces
        a new model where a specific {\it Provided} annotation is
        \quote{compiled} into its equivalent formal specification. For example,
        after application of this operator the goal \goal{Achieve [Make Up Pump Motor On When Water Requested]}
         is specified without its {\it Provided} annotation as follows:
       
       \startkaosspec
         \GoalName {Achieve [Make Up Pump Motor On When Water Requested]}
         \KaosAttribute {FormalSpec} {
           $WaterRequested \wedge \neg PumpMechanicalFailure$\blank[none]
           \hskip2.5cm$\Rightarrow \ltlF_{\leq 5m} PumpMotorOn$
         }
       \stopkaosspec
       
        \noindent {\bi Detach-RelaxedTo}, applied to an annotated goal,
        produces a new model where a specific {\it RelaxedTo} annotation is
        removed. Back to an earlier example, the application of this operator
        to the goal \goal{Achieve [Make Up Pump Motor On When Water Requested]}
        yields the following goal specification:
       
       \startkaosspec
         \GoalName {Achieve [Make Up Pump Motor On When Water Requested]}
         \KaosAttribute {FormalSpec} {$WaterRequested \Rightarrow [ \ltlF_{\leq 5m} PumpMotorOn $\blank[none]
           \hskip2.5cm$\vee\hskip.5em\ltlF_{\leq 10m} RedundantPumpMotorOn ]$}
       \stopkaosspec
         
        Similarily, three operators are available for transforming a standard
        model portion into an annotated one\emdash{}namely, {\it
        Attach-Except}, {\it Attach-Provided} and {\it Attach-RelaxedTo}. These
        operators are the reverse of the {\it Detach} ones.
            
      \noindent {\bf Exception diagrams.} Textual goal specifications with {\it
      Except} and {\it Replaces} annotations may be graphically represented in
      an exception diagram. \in{Figure}[fig:exception_diagram] shows two
      portions of such a diagram for the goals \goal{Achieve [Make Up Water
      Requested When Alarm Raised]} and \goal{Achieve [Make Up Pump Motor On
      When Water Requested]}. This diagram captures that 
      
      \startitemize[a]
      
        \item This goal replaces the similar goal assigned to the \agent{Operator} agent
        ;
      
        \item When the obstacle \obstacle{Pump Mechanical Failure} or
        \obstacle{Pump Electrical Failure} occurs the countermeasure goal
        \goal{Achieve [Redundant Pump Motor On When Primary Pump Failure]} will
        guarantee this goal.
      
      \stopitemize

        \placefigure[page]
        	[fig:exception_diagram]
        	{Exception diagrams.}
          {\startcombination[1*2]
            {\externalfigure[../images/chap5/exception_diagram_a.pdf]}{\tfx(a) Exception diagram with a {\it replace} annotation.}
            {\externalfigure[../images/chap5/exception_diagram_b.pdf]}{\tfx(b) Exception diagram with two {\it except} annotations.}
           \stopcombination
          }
      
      \stopsubsubsection
      
    \stopsubsection
  
  \stopsection
  
	\section{Summary}
  
    This chapter presented techniques for controlling likely and critical
    obstacles. The latter are resolved through valid countermeasures in order
    to produce more complete requirements. Countermeasures are selected to
    maximize the satisfaction rate of high-level goals while minimizing the
    resolution cost. Our integration operator guarantees three properties,
    namely, {\it progress} towards a more complete goal model, {\it minimal
    changes}, and {\it correctness preservation}. A valid countermeasure goals
    guarantees {\it progress}; once the countermeasure is integrated, the
    satisfaction rate of some high-level goal(s) increases. Such increase
    quantifies the impact of a countermeasure and drives the selection of
    appropriate countermeasures. The chapter proposed two integration schemas,
    to be selected according the specific resolution tactic being used, to
    guarante {\it minimal change} to the original model. Propagating the
    changes through guarantee the correctness of the new model. However, such
    integrations intermixes ideal and exceptional cases. To mitigate this,
    extensions to the goal specification language were proposed to specify
    exceptions and de-idealization to goals together with refactoring
    operators. Exceptions may then be visualized in exception diagrams.
    
    The techniques presented so far always assume a single-value for goal
    satisfaction rates. The next chapter introduce uncertainty about the
    satisfaction rates and details how such uncertainty may impact the
    assessment of most critical obstacles.
      
    % TODO 
      % BDD with all possible resolutions
      % Draft the BDD with partial-entailement refinements + explain in the text
    
\stopcomponent
