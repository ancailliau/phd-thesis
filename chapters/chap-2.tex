% !TEX root = thesis.tex

\startcomponent chap-2
\environment common
\product thesis

\chapter
    [reference=chap-background,
     title={Background: Goal-Oriented Requirements Engineering}]
   
  This chapter introduces the necessary background in goal-oriented
  requirements engineering and introduces the KAOS framework extended by the
  following chapters. \in{Section}[sec:background_goal] presents how system
  objectives are modeled as goals in the KAOS framework.
  \in{Section}[sec:background_obstacle] describes how to anticipate what could
  go wrong through obstacle analysis.

    \startsection[reference=sec:background_goal,title={Modelling System Objectives with KAOS}]
  
    Goal-oriented requirements engineering is recognized as a major modeling
    technique for engineering requirements of complex, mission-critical,
    software systems emphasizing on the {\it why} of resulting software
    specifications \cite[Lam09a]. Among the goal-oriented frameworks, the KAOS
    framework proposes a formal approach where objectives of a system are
    defined in a precise, clear-cut sense \cite[Lam09a], on the contrary of
    other approaches such as i* where the system satisfies the goals at various
    degrees \cite[Yu97a].
    
    This section presents the fragments of the KAOS framework used in this
    thesis. In particular, the KAOS framework is a multi-view modeling approach
    including a goal, an object, an agent responsibility, an operations and a
    behavior model. We focus here on goal modeling only, a detailed
    presentation of the framework can be found in \cite[Lam09a].
    
    \subsection{Defining Goals, Software Requirements, and Domain Assumptions}
    
      A {\it goal} is a prescriptive statement of intent to be satisfied by the
      agents forming the system. An {\it agent} is an active system component
      having responsibilities in goal satisfaction. An agent has capabilities
      regarding conditions the agent can monitor or control. The word {\it
      system} refers to the software-to-be together with its environment,
      including pre-existing software, devices such as sensors and actuators,
      people, etc.
      
      For example, a goal in a nuclear spent fuel pool would be that makeup
      water is provided when there is a loss of cooling in the pool. The
      following specification captures this goal

      \startkaosspec
          \GoalName {Achieve [Make Up Water Provided When Loss Of Cooling]}
          \KaosAttribute {Definition} {
            When the pool is not cooled appropriately, cold makeup water is provided.
        }
      \stopkaosspec
    
      A goal may be {\it behavioral} or {\it soft} dependent on whether it can
      be satisfied in a clear-cut sense or not. In the context of risk
      analysis, the thesis focuses on behavioral goals. We briefly present soft
      goals in a later subsection.
    
      A behavioral goal captures a maximal set of intended behaviors
      declaratively and implicitly; a {\it behavior} is a sequence of system
      states. A behavior thus violates a goal if it is not among those
      prescribed by the formal specification of the goal \cite[Lam09a]. The
      notation $\pi \vDash G$ expresses that the behavior $\pi$ satisfies the
      goal $G$.
      
      As seen later, a goal AND/OR graph organizes the goals through refinement
      links. In such goal model, leaf goals assigned to a software agent are
      {\it requirements} whereas leaf goals assigned to an environment agent
      are {\it expectations}.
      
      Each goal has a {\it name}, a natural language {\it definition} and an
      optional {\it formal definition} (we present formal definitions later in
      this section). The above goal's name is \goal{Achieve [MakeUp Water
      Provided When Loss Of Cooling]}.
    
    \subsection {Defining Domain Properties and Domain Hypotheses}
    
      Unlike goals, {\it domain properties} are descriptive statements about
      the problem world (such as physical laws). A domain property is naturally
      true in the system-to-be. Domain properties play a critical role when
      refining goals and obstacles. An example of domain property in our
      running example is the fact that an electrical pump cannot operate
      without electrical power.

      \startkaosspec
          \DomPropName {Power Required For Motor Pump On}
          \KaosAttribute {Definition} {
            Electrical power is required to turn the motor on.
        }
      \stopkaosspec
      
      Expectations, as seen in the previous section, are prescriptive
      assumptions on the environment. Descriptive assumptions, called {\it
      domain hypotheses}, may be needed as well. Domain hypotheses differ from
      domain properties as they are not necessarily true in the system but are
      assumed, by the analyst, to be true. For example, the fact that a pump
      might not be turned on when its internal electrical relay is broken.

      \startkaosspec
          \DomHypName {No Electrical Failure For Motor Pump On}
          \KaosAttribute {Definition} {
            An electrical failure prevents the pump motor to be on.
        }
      \stopkaosspec
    
      A behavioral goal must obviously be consistent with all known domain properties, that is,
    
      \startformula
      \{G, Dom\} \vDash\not false    \hskip1.5cm\text{(domain-consistency)}
      \stopformula
        
    \subsection {Specifying Formal Assertions}
    
      (Metric) Linear temporal logic (LTL) \cite[Koy92a,Man92a] may be used for
      formalizing behavioral goals to enable their analysis. The goals then
      take the general form
    
      \startformula
        C \Rightarrow \Theta T
      \stopformula
    
      where $\Theta$ represents a LTL operator such as: $\ltlX$ (in the next
      state), $\ltlF$ (sometimes in the future), $\ltlF_{\leq d}$ (sometimes in
      the future before deadline $d$), $\ltlG$ (always in the future),
      $\ltlG_{\geq d}$ (always in the future up to deadline $d$), $\ltlW$
      (always in the future unless), $\ltlU$ (always in the future until), and
      where $C \Rightarrow \Theta T$ means $\ltlG(C \rightarrow \Theta T)$. The
      following standard logical connectives are used: $\wedge$ (and), $\vee$
      (or), $\neg$ (not), $\rightarrow$ (implies), $\leftrightarrow$
      (equivalent).
      
      A behavioral goal can be of type {\it Achieve} or {\it Maintain/Avoid}
      \cite[Lam09a]. The specification pattern for an {\it Achieve} goal is:
      
      \startformula
        \text{{\ss {\bf if} C {\bf then sooner-or-later} T},}\hskip1em\text{that is,}\hskip1emC \Rightarrow \ltlF T,
      \stopformula
        
      where $C$ denotes a current condition and $T$ a target condition, with
      obvious particularizations to {\it Immediate Achieve} ($C \Rightarrow
      \ltlX T$) and {\it Bounded Achieve} ($C \Rightarrow \ltlF_{\leq d} T$)
      \cite[Lam09a].
    
      \noindent The specification pattern for a {\it Maintain} goal is:
      
      \startformula
        \text{{\ss [{\bf if} C {\bf then}] {\bf always} G},}\hskip1em\text{that is,}\hskip1em[C \Rightarrow] \ltlG G,
      \stopformula
        
      the specification pattern for an {\it Avoid} goal is:
        
      \startformula
        \text{{\ss [{\bf if} C {\bf then}] {\bf never} B},}\hskip1em\text{that is,}\hskip1em[C \Rightarrow] \ltlG \neg B,
      \stopformula
        
      where $G$ and $B$ denote a good condition and a bad condition,
      respectively. (Brackets are used here to delimit optional parts in those
      patterns.)
    
    \subsection {Modelling Goals as AND/OR Graphs}
    
      A goal model is an AND/OR graph showing how goals contribute positively
      or negatively to each other \cite[Gio03a,Lam09a]. Parent goals are
      obtained by abstraction, e.g., through {\it why} questions, whereas child
      goals are obtained by refinement, e.g., through {\it how} questions.
      Refinement paths connect goal nodes in this graph to their ancestor
      nodes. Leaf goals are assignable to single system agents. (As a recall, a
      leaf goal is a {\it requirement} if assigned to a single software agent,
      whereas it is an {\it expectation} if assigned to an environment agent.)
      Graphically, goals are represented by parallelograms, domain properties
      by \quote{home} shapes and agents by hexagons, see
      \in{Figure}[fig:background_make_up_water_provided].

      \placefigure[]
          [fig:background_make_up_water_provided]
          {Refinement of \goal{Achieve [Make Up Water Provided When Loss Of Cooling]}.}
        {\externalfigure[../images/chap4/make_up_water_provided.pdf]}

      Refinement patterns are available to help building goal models, e.g., the
      {\it Milestone-Driven}, {\it Case-Driven}, {\it Guard-Introduction}, {\it
      Unmonitorability-Driven}, {\it Uncontrollability-Driven}, or {\it
      Divide-and-Conquer} patterns \cite[Dar96a,Lam09a].
    
      In \in{Figure}[fig:background_make_up_water_provided], the two top
      refinements are {\it Milestone-Driven} (with {\ss Make Up Water
      Requested} as the milestone condition). The left refinement follows the
      {\it Milestone-Driven} refinement pattern (with {\ss Alarm Raised} as the
      milestone condition). The right refinement follows the {\it
      Divide-and-Conquer} refinement pattern. For example, the top goal is more
      precisely specified as follows:
    
      \startformula
        LossOfCooling \Rightarrow \ltlF_{\leq 55h} MakeUpWaterProvided
      \stopformula    
    
      Its two subgoals are obtained by application of the {\it
      Milestone-Driven} refinement pattern with $MakeUpWaterRequested$ as
      milestone condition:
    
      \startformula\startalign[n=1]
        \NC LossOfCooling \Rightarrow \ltlF_{\leq 5h} MakeUpWaterRequested \NR 
        \NC MakeUpWaterRequested \Rightarrow \ltlF_{\leq 50h} MakeUpWaterProvided \NR 
      \stopalign\stopformula
    
      AND-refinements in a goal model should be correct, that is, complete,
      consistent and ideally minimal \cite[Lam09a].
 
      \startitemize
    
        \item A refinement is {\it complete} if the satisfaction of all
        subgoals is sufficient for the satisfaction of the parent goal given
        known domain properties:
    
        \startformula
            \{SG_1, SG_2, ..., SG_n, Dom\} \vDash PG    \hskip2cm\text{(complete refinement)}
        \stopformula
    
        \item A refinement is {\it consistent} if no subgoal contradicts other
        subgoals in the domain:

        \startformula
            \{SG_1, SG_2, ..., SG_n, Dom\} \vDash\not false \hskip2cm\text{(consistent refinement)}
        \stopformula
    
        \item A refinement is {\it minimal} if all the subgoals are needed for
        the satisfaction of the parent goal:

        \startformula
            \{\bigwedge_{j\neq i}SG_j, Dom\} \vDash\not G \hskip1em 
            \text{for all } i \text{ s.t. } 1 \leq i \leq n  \hskip1cm\text{(minimal refinement)}
        \stopformula
    
      \stopitemize
    
      A goal refinement obtained by instantiation of a refinement pattern is
      formally guaranteed to be complete, consistent and minimal
      \cite[Dar95a,Lam09a]; the correctness proof is done once for all on the
      temporal logic formalization of the pattern. The partial goal model in
      \in{Figure}[fig:background_make_up_water_provided] shows three complete,
      consistent and minimal AND-refinements.
    
    \subsection{Goal conflicts}
    
      In a goal model, goals may be connected by conflict links if the goals
      are potentially conflicting. Goals are potentially conflicting (or
      divergent) if there exists a satisfiable and non-trivial boundary
      condition $B$ making them logically inconsistent in the domain
      \cite[Lam09a], that is:

      \startformula\startalign[n=1,align={left}]
          \NC \{ B, SG_1, SG_2, ..., SG_n, Dom \} \vDash false,\hskip2cm\text{(conflict)}\NR
        \NC \{ B, Dom \} \vDash\not false         \NR
      \stopalign\stopformula
    
      The condition $B \wedge Dom$ has to be realizable by the environment.
      Such environment monitors all the variables constrained by the goals and
      controls all the other ones \cite[De-07a].
        
    \subsection{Soft Goals as Optimisation Criteria}
    
      In addition to behavioral goals, soft goals are goals that are not
      satisfied in a clear-cut sense \cite[Myl92a,Myl99a]\emdash{}e.g., \goal{User
      interface usable} or \goal{Fast computation}. Soft goal are more or less
      satisfied depending on the behavioral goals contributing positively or
      negatively to the soft goal.
      
      Soft goals are used as optimisation criteria to enable alternative
      designs comparison \cite[Let02a,Lam09a,Hea11a]. Typically, soft goals are
      used in minimization/maximization function to be optimized by the
      system-to-be such as \goal{Maximize[Computation Speed]} or
      \goal{Minimize[Energy consumption]}. These {\it Maximize/Minimize} goals
      are refered as {\it optimization goals}.
    
  \stopsection
  
    \startsection[reference=sec:background_obstacle,title={Anticipating What Could Go Wrong: Obstacle Analysis}]
  
    In goal-oriented modeling frameworks, obstacles were introduced as a
    natural abstraction for risk analysis \cite[Pot95a,Ant98a,Lam00a]. This
    section defines obstacles, how they relate to goals and other obstacles,
    and presents techniques to identify, assess and control obstacles
    preventing the software to meet its goals.
    
    \subsection {What are Obstacles?}

      An {\it obstacle} to a goal is a domain-satisfiable precondition for the
      non-satisfaction of this goal \cite[Lam00a,Lam09a]:
      
      \startformula\startalign[n=2,align={left,left}]
        \NC \{O, Dom\} \vDash \neg G \hskip2cm \NC \text{(obstruction)}\NR
        \NC \{O, Dom\} \vDash\not false \NC \text{(domain-consistency)}\NR
      \stopalign\stopformula
      
      For example, for our spent fuel pool system, an obstacle to the goal
      \goal{Achieve [Make Up Pump Motor On When Water Requested]} is
      \obstacle{No Power Available}.
      
      \startkaosspec
          \ObstacleName {No Power Available}
          \KaosAttribute {Definition} {
            No electrical power is available at the pump.
        }
      \stopkaosspec
      
      \noindent This obstacle satisfies both the (obstruction) condition, if
      there is no power, the motor pump cannot be on; and the
      (domain-consistency) condition, it is possible that no power is available.
      
      Each obstacle has a {\it name}, a natural language {\it definition} and
      an optionnal {\it formal definition}. The above obstacle's name is
      \obstacle{No Power Available}.
        
    \subsection {Specifying Formal Assertions}
    
      As goals, obstacles might be formalized using (Metric) Linear temporal
      logic (LTL) \cite[Koy92a,Man92a]. An obstacle to
      a goal $C \Rightarrow \Theta T$ then takes the general form
    
      \startformula
        \ltlF (C \wedge \neg \Theta T)
      \stopformula
    
      where $\Theta$ represents a LTL operator. We often used the general form
      $\ltlF(C \wedge \Theta OC)$ where $OC$ is the obstacle condition. An
      obstacle to an {\it Achieve} goal is:
      
      \startformula
        \text{{\ss {\bf sooner-or-later} C {\bf and never} T},}\hskip1em\text{that is,}\hskip1em\ltlF(C \wedge \ltlG \neg T),
      \stopformula
      
      where $C$ denotes a current condition and $T$ a target condition
      \cite[Lam09a]. An obstacle to a {\it Maintain} goal is:
      
      \startformula
        \text{{\ss [{\bf sooner-or-later} C {\bf and}] {\bf sooner-or-later not} G},}\hskip1em\text{that is,}\hskip1em\ltlF(C \wedge \ltlF\neg G)
      \stopformula
       
      and an obstacle to an {\it Avoid} goal is:
      
      \startformula
        \text{{\ss [{\bf sooner-or-later} C {\bf and}] {\bf sooner-or-later} B},}\hskip1em\text{that is,}\hskip1em\ltlF(C \wedge \ltlF B)
      \stopformula
       
      where $G$ and $B$ denote a good condition and a bad condition,
      respectively.
    
    \startsubsection[title={Modelling Obstacles as AND/OR Graph}]
    
      Similar to goals, obstacles can be AND/OR refined into subobstacles,
      resulting in a goal-anchored form of risk tree. In an obstacle tree,
    
      \startitemize[packed]
    
        \item the root obstacle is the negation of the associated leaf goal in
        the goal model, that is for a root obstacle $RO$ to a leaf goal $LG$:
        
        \startformula
          \{RO, Dom\} \vDash \neg LG\hskip2cm\text{(obstruction)}
        \stopformula
    
        \item an AND-refinement captures a combination of subobstacles
        entailing the parent obstacle;
    
        \item an OR-refinement captures alternative ways of entailing the
        parent obstacleâ€”and, recursively, of obstructing the corresponding leaf
        goal; These refinements are ideally disjoint.
    
        \item the leaf subobstacles are single, fine-grained obstacles whose
        likelihood can be easily estimated.
    
      \stopitemize
    
      \noindent Considering $n$ OR-Refinements to a parent obstacle $PO$, each
      with a single subobstacle $SO_i$ (for $1 \leq i \leq n$), the
      conditions above can formaly specified as follows. (The generalization to
      more subobstacles in a given OR-Refinement is straightforward.) The
      subobstacle $SO_i$ in an OR-refinement must entail the parent obstacle:
    
      \startformula
        \{ SO_i, Dom \} \vDash PO \hskip2cm\text{(entailment)}
      \stopformula
        
      OR-refinements should ideally be domain complete and disjoint, i.e.
      
      \startformula\startalign[n=2,align={left,left}]
        \NC \{\neg SO_1, ..., \neg SO_n, Dom\} \vDash \neg PO \hskip2cm \NC \text{(domain-completeness)}\NR
        \NC \text{for all } i \neq j, \{SO_i, SO_j, Dom\} \vDash false \hskip1cm\NC \text{(disjointness)}\NR
      \stopalign\stopformula
    
    \subsection {Obstacle Analysis}
    
    Obstacle analysis consists of identifying missing or inadequate goals. It
    includes three steps \cite[Lam00a]:
    
    \startitemize[a]
    
      \item {\it Obstacle Identification:} as many obstacles as possible to
      every leaf goal in the goal refinement graph should be identified from
      relevant domain properties.
    
      \item {\it Obstacle Assessment:} the likelihood and severity of each
      obstacle should be determined.
    
      \item {\it Obstacle Resolution:} likely and critical obstacles should be
      resolved through appropriate countermeasures to integrate next in the
      ideal goal model.
    
    \stopitemize
    
    \noindent A new cycle of obstacle analysis might then be performed on the
    countermeasure goals. The following briefly details the above steps.
    
    \noindent {\bf Obstacle Identification.} Formal and heuristic techniques
    are available for the identification of obstacles
    \cite[Ant98a,Sut98b,Lam00a,Lam09a,Alr12].
    
    In particular, for the {\it Achieve} and {\it Maintain/Avoid} goal
    specification patterns introduced in \in{Section}[sec:background_goal],
    specific domain properties are worth eliciting. They take the form:
      
    \startformula
      \text{{\ss {\bf always} {\bf if} Q {\bf then} N},}\hskip1em\text{that is,}\hskip1emQ\Rightarrow N,
    \stopformula
    
    where $N$ denotes a necessary condition for the consequent $Q$ of a leaf
    goal $P\Rightarrow \Theta Q$. $Q$ is the target condition $T$ of an {\it
    Achieve} goal $C\Rightarrow \ltlF T$ or the good condition $G$ of a {\it
    Maintain} goal $C\Rightarrow G$. Such domain properties result in obstacles
    taking the form:
    
    \startformula
      \text{{\ss {\bf sooner-or-later} C {\bf and never} N},}\hskip1em\text{that is,}\hskip1em\ltlF(C \wedge \ltlG\neg N),
    \stopformula
      
    for an {\it Achieve} goal, or 
    
    \startformula
      \text{{\ss {\bf sooner-or-later} C {\bf and sooner-or-later not} N},}\hskip1em\text{that is,}\hskip1em\ltlF(C \wedge \ltlF\neg N),
    \stopformula
      
    for a {\it Maintain} goal.
  
    Consider the goal \goal{Achieve [Make Up Pump Motor On When Water
    Requested]} in \in{Figure}[fig:background_make_up_water_provided] whose
    target condition is {\ss PumpMotorOn}:
    
    \startformula
      WaterRequested \Rightarrow \ltlF_{\leq 5m} PumpMotorOn
    \stopformula
    
    Negating this goal yields the root obstacle: 
    
    \startformula
      \ltlF (WaterRequested \wedge \ltlG_{\geq 5m} \neg PumpMotorOn)
    \stopformula
        
    The necessary conditions for the target include the following:
    
    \startformula
      PumpMotorOn \Rightarrow \neg PumpElectricalFailure
    \stopformula
    
    This yields the bottom left subobstacle in
    \in{Figure}[fig:background_make_up_water_pump_on], namely:
    
    \startformula
      \ltlF (WaterRequested \wedge \ltlG_{\geq 5m} PumpElectricalFailure)
    \stopformula
        
    \placefigure[]
        [fig:background_make_up_water_pump_on]
        {Obstacles for \goal{Achieve [Make Up Pump Motor On When Water Requested]}.}
      {\externalfigure[../images/chap4/make_up_water_pump_on.pdf]}

    \noindent {\bf Obstacle Assessment.} Obstacle assessment is concerned about
    identifying the critical and likely obstacles to be resolved during the
    next phase, obstacle control. Very little work is available regarding
    obstacle assessment; \in{Chapter}[chap:assessing] will detail our
    contribution to obstacle assessment.
    
    \noindent {\bf Obstacle Control.} The identified obstacles, if likely and
    critical shall be resolved through appropriate countermeasures. The
    identified countermeasure goals shall be refined until assigned to single
    agents. Most appropriate countermeasures are then selected according to a
    variety of criteria such as the number of obstacles resolved or the
    likelihood and criticality of resolved obstacles \cite[Lam09a]. The
    selected countermeasures are then deployed at RE time, or at runtime. Very
    little work is available on countermeasure selection and integration;
    \in{Chapter}[chap:controlling_obstacle] and \in{Chapter}[runtime] will discuss
    these techniques both at RE time and runtime.
         
    As for obstacle identification, formal and heuristic techniques are
    available for the generation of alternative countermeasure goals
    \cite[Lam00a,Alr16]. A variety of tactics are available for exploring
    alternative ways of resolving obstacles to a goal\emdash{}such as {\it
    avoid obstacle} (adds a new goal requiring the obstacle to be avoided),
    {\it reduce obstacle likelihood} (adds a new goal that reduces the
    likelihood of occurence for the obstacle), {\it mitigate obstacle} (adds a
    new goal to mitigate the consequence of the obstacle, ensuring a weakened
    version of the obstructed goal or of one of its ancestor), {\it weaken
    goal} (weakens the obstructed goal so that the obstruction no longer
    occurs), {\it substitute goal} (replace the obstructed goal by a new goal,
    not obstructed by the obstacle under consideration), {\it restore goal}
    (adds a new goal to ensure the obstructed goal is satisfied in a reasonable
    future), or {\it substitute agent} (replace the agent responsible for the
    obstructed goal so that the obstacle is no longer feasible)
    \cite[Lam00a,Lam09a]. For example, the obstacle mitigation tactic applied
    to the preceding obstacle \obstacle{Pump Electrical Failure} generates the
    following countermeasure goal:
    
    \startkaosspec
        \GoalName {Achieve [Redundant Pump Motor On When Primary Pump Failure]}
        \KaosAttribute {FormalDef} {
          $WaterRequested \wedge PumpElectricalFailure$\blank[none]
          \hskip2.5cm$\Rightarrow \ltlF_{\leq 5m} RedundantPumpMotorOn$
      }
    \stopkaosspec
    
  \stopsection
  
  \startsection[title={Summary}]
  
    This chapter introduced the goal-oriented requirement engineering framework
    KAOS together with obstacle analysis. Next chapter will introduce the
    probabilistic framework, extending the framework presented in this chapter,
    with probabilistic goals and probabilistic obstacles, laying the
    foundations for the techniques presented in the following chapters.
  
  \stopsection

\stopcomponent
